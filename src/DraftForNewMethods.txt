public class DraftForNewMethods {

    // In Node Class
//    // Setting CellTypeAlgo method --- --- --- /// --- --- --- /// --- --- --- /// --- --- ---
//
//    // open = FOCUS
//    public void setTypeAsFocus() {
//        cellTypeAlgo = CellTypeAlgo.FOCUS;
//        setBackground(CellTypeAlgo.FOCUS.color);
//    }
//    public void setAsChecked() {
//        if (cellTypeTerrain != CellTypeTerrain.START && cellTypeTerrain != CellTypeTerrain.TARGET) {
//            cellTypeAlgo = CellTypeAlgo.CHECKED;
//            setBackground(CellTypeAlgo.CHECKED.color);
//        }
//    }
//    public void setTypeAsPath() {
//        setBackground(CellTypeAlgo.PATH.color);
//        cellTypeAlgo = CellTypeAlgo.PATH;
//    }


        private void focusNode (Node node) {
            if (node.cellTypeAlgo != CellTypeAlgo.FOCUS && node.cellTypeAlgo != CellTypeAlgo.CHECKED && node.cellTypeTerrain != CellTypeTerrain.WALL) {

                node.setTypeAsFocus();
                node.parent = currentNode2;

                int newGCost = getNewGCost(node);
                if (newGCost < node.gCost) {
                    node.gCost = newGCost;
                    node.fCost = node.gCost + node.hCost;
                    node.setText("<html>F:" + node.fCost + "<br>G:" + node.gCost + "<br>H:" + node.hCost + "</html>");
                }



                focusList.add(node);
            }
        }

    // In Map Panel Class
    //
    // Calculate G costs

    public void calculateGAndFCosts (Node node) {

                int parentColumn;
                int parentRow;
                int parentGCost;

                if (node.parent == null) {
                    parentColumn = startNode.column;
                    parentRow = startNode.row;
                    parentGCost = 0;
                } else {
                    parentColumn = node.parent.column;
                    parentRow = node.parent.row;
                    parentGCost = node.parent.gCost;
                }

                int xDistance = Math.abs(node.column - parentColumn);
                int yDistance = Math.abs(node.row - parentRow);
                //node.gCost = (int) (10 * Math.sqrt(xDistance*xDistance + yDistance*yDistance));
                //
                return parentGCost + (int) (10 * (Math.max(xDistance, yDistance) + Math.min(xDistance, yDistance) * (Math.sqrt(2) - 1)));

    }
                 // 4 Direction Check
                 // Focus the upper cell if there is one
                 if (r - 1 > -1)
                     focusNode(nodeMatrix[c][r - 1]);
                 // Focus the left cell if there is one
                 if (c - 1 > -1)
                     focusNode(nodeMatrix[c - 1][r]);
                 // Focus the down cell if there is one
                 if (r + 1 < rows)
                     focusNode(nodeMatrix[c][r + 1]);
                 // Focus the right cell if there is one
                 if (c + 1 < columns)
                     focusNode(nodeMatrix[c + 1][r]);

                 // * Direction Check (+4)
                 // Focus the upper-left cell if there is one
                 if (r - 1 > -1 && c - 1 > -1 && !(nodeMatrix[c - 1][r].cellTypeTerrain == CellTypeTerrain.WALL && nodeMatrix[c][r - 1].cellTypeTerrain == CellTypeTerrain.WALL))
                     focusNode(nodeMatrix[c - 1][r - 1]);
                 // Focus the down-left cell if there is one
                 if (r + 1 < rows && c - 1 > -1 && !(nodeMatrix[c - 1][r].cellTypeTerrain == CellTypeTerrain.WALL && nodeMatrix[c][r + 1].cellTypeTerrain == CellTypeTerrain.WALL))
                     focusNode(nodeMatrix[c - 1][r + 1]);
                 // Focus the upper-right cell if there is one
                 if (r - 1 > -1 && c + 1 < columns && !(nodeMatrix[c + 1][r].cellTypeTerrain == CellTypeTerrain.WALL && nodeMatrix[c][r - 1].cellTypeTerrain == CellTypeTerrain.WALL))
                     focusNode(nodeMatrix[c + 1][r - 1]);
                 // Focus the down-right cell if there is one
                 if (r + 1 < rows && c + 1 < columns && !(nodeMatrix[c + 1][r].cellTypeTerrain == CellTypeTerrain.WALL && nodeMatrix[c][r + 1].cellTypeTerrain == CellTypeTerrain.WALL))
                     focusNode(nodeMatrix[c + 1][r + 1]);

}


    private void focusNode (Node node, int potentialNewGCost) {
        if (node.cellTypeAlgo != CellTypeAlgo.FOCUS && node.cellTypeAlgo != CellTypeAlgo.CHECKED && node.cellTypeTerrain != CellTypeTerrain.WALL) {

            node.setTypeAsFocus();

            if (potentialNewGCost < node.gCost) {
                node.gCost = potentialNewGCost;
                node.fCost = node.gCost + node.hCost;
                node.setText("<html>F:" + node.fCost + "<br>G:" + node.gCost + "<br>H:" + node.hCost + "</html>");
            }

            node.parent = currentNode2;
            focusList.add(node);
        }
    }

    public void autoSearch(Node startNode) {
        currentNode2 = startNode;

        while (!targetReached && step < 1000) {
            int c = currentNode2.column;
            int r = currentNode2.row;

            currentNode2.setAsChecked();
            checkedList.add(currentNode2);
            focusList.remove(currentNode2);

                        // 4 Direction Check
                        // Focus the upper cell if there is one
                        if (r - 1 > -1)
                            focusNode(nodeMatrix[c][r - 1], currentNode2.gCost + 10);
                        // Focus the left cell if there is one
                        if (c - 1 > -1)
                            focusNode(nodeMatrix[c - 1][r], currentNode2.gCost + 10);
                        // Focus the down cell if there is one
                        if (r + 1 < rows)
                            focusNode(nodeMatrix[c][r + 1], currentNode2.gCost + 10);
                        // Focus the right cell if there is one
                        if (c + 1 < columns)
                            focusNode(nodeMatrix[c + 1][r], currentNode2.gCost + 10);
                        // * Direction Check (+4)
                        // Focus the upper-left cell if there is one
                        if (r - 1 > -1 && c - 1 > -1 && !(nodeMatrix[c - 1][r].cellTypeTerrain == CellTypeTerrain.WALL && nodeMatrix[c][r - 1].cellTypeTerrain == CellTypeTerrain.WALL))
                            focusNode(nodeMatrix[c - 1][r - 1], currentNode2.gCost + 14);
                        // Focus the down-left cell if there is one
                        if (r + 1 < rows && c - 1 > -1 && !(nodeMatrix[c - 1][r].cellTypeTerrain == CellTypeTerrain.WALL && nodeMatrix[c][r + 1].cellTypeTerrain == CellTypeTerrain.WALL))
                            focusNode(nodeMatrix[c - 1][r + 1], currentNode2.gCost + 14);
                        // Focus the upper-right cell if there is one
                        if (r - 1 > -1 && c + 1 < columns && !(nodeMatrix[c + 1][r].cellTypeTerrain == CellTypeTerrain.WALL && nodeMatrix[c][r - 1].cellTypeTerrain == CellTypeTerrain.WALL))
                            focusNode(nodeMatrix[c + 1][r - 1], currentNode2.gCost + 14);
                        // Focus the down-right cell if there is one
                        if (r + 1 < rows && c + 1 < columns && !(nodeMatrix[c + 1][r].cellTypeTerrain == CellTypeTerrain.WALL && nodeMatrix[c][r + 1].cellTypeTerrain == CellTypeTerrain.WALL))
                            focusNode(nodeMatrix[c + 1][r + 1], currentNode2.gCost + 14);

            // Find the best cell
            int bestNodeIndex = 0;
            int bestNodeFCost = Integer.MAX_VALUE;

            for (int i = 0; i < focusList.size(); i++) {
                // Check if this node's F cost is lower
                if (focusList.get(i).fCost < bestNodeFCost) {
                    bestNodeIndex = i;
                    bestNodeFCost = focusList.get(i).fCost;
                } else if (focusList.get(i).fCost == bestNodeFCost) {
                    // IF F cost are same check min G cost
                    if (focusList.get(i).gCost < focusList.get(bestNodeIndex).gCost) {
                        bestNodeIndex = i;
                    }
                }
            }

            // After the loop we have next step cell
            currentNode2 = focusList.get(bestNodeIndex);

            if (currentNode2.targetNode) {
                targetReached = true;
                trackThePath();
            }
            step++;
        }

    }



// --- --- --- ||| --- --- --- ||| --- --- --- ||| --- --- --- Works Well --- --- --- ||| --- --- --- ||| --- --- --- ||| --- --- ---

    // Backtrack the best path --- --- --- ||| --- --- --- ||| --- --- --- ||| --- --- ---
    private void trackThePath () {
        Node current = targetNode;
        while (current != startNode) {
            current = current.parent;
            if (current != startNode) {
                current.setTypeAsPath();
            }
        }
    }
